---
layout:		post
title:		"STL & Iterator (컨테이너와 반복자)"
category:	c++
date:		2022-11-24 7:54:00 +0900
---

##STL이란 ??

Standard Template Library 의 약자를 말하며, C++ 에서 기본적으로 제공되는 템플릿들을 말한다. 그럼 여기서 템플릿은 무엇이냐?

### template
템플릿을 설명하기 위해선 C언어를 먼저 살펴 볼 필요가 있다.
C언어에서, 우리가 `void swap(int *a, int *b)` 이라는, parameter로 들어온 a와 b의 값을 서로 교환하는 함수를 구현했다고 가정을 해보자.
해당 함수는 `int *` 에 대해서만 작동을 할 것이다. 추가적으로 `char *`에 대해서도 값을 교환하는 함수를 구현하고 싶다면 `함수명이 겹치지 않게`, 또 다른 함수를 선언을 해주어야 될 것이다.
이것의 문제점은, 기능은 거의 유사하지만 데이터 타입별로 함수이름을 전부 다르게 해줘야 하는 번거로움이 생긴다.

이것을 해결하기 위해 C++에서 제공하는 기능이 바로 `Over Loading`이다.
같은 함수명 일지라도, parameter가 달라지면 다른 함수로 취급이 된다. 이렇게 되면 동일한 기능을 하는 함수에, 동일한 함수명을 부여할 수 있어 데이터 타입에 따라 함수명을 다르게 써야하는 번거로움을 확 없애줄 수 있다.

그런데... 여기에서 한 발짝 더 나아가서, 데이터 타입별로 함수를 선언하는 것 조차도 귀찮고 번거로워서 사용하는 것이 바로 `template` 이다.

- 예시
```c++
/* 오버로딩 */
void swap(int *a, int *b)
{
	int tmp = *a;

	*a = *b;
	*b = tmp;
}

void swap(char *a, char *b)
{
	char tmp = *a;

	*a = *b;
	*b = tmp;
}
... 함수명은 같다는 장점이 있지만, 일일이 선언해주기 귀찮다...


/* 템플릿 함수 선언 */
template <class T>
void swap(T *a, T *b)
{
	T tmp = *a;

	*a = *b;
	*b = tmp;
}
```
어떠한 타입이 들어오면 컴파일 단계에서 T의 값을 그 타입으로 치환해서 컴파일 해준다. 그래서 이렇게 한 번만 정의를 해놓으면 해당 함수를 사용할 수 있다.


다시, 본론으로 돌아와서 STL이란, 유용한 템플릿들을 모아둔 라이브러리 라고 생각하면 된다.


### Container
그렇다면, 컨테이너는 무엇이냐. 말 그대로 무언가를 담는 것을 말한다.
C에서는 데이터를 관리하는 여러 방법이 있겠지만, 그 중에서 대표적으로 배열이 있을 것이다. char 배열이면 char [], int 배열이면 int [] .... 역시 이렇게 하나 하나 선언을 해줘야 하는 번거로움이 생긴다.

컨테이너는, 이런 번거로움을 해결해주는 애들인데, 쉽게 말해서 `템플릿 배열`이라고 생각하면 된다 (그렇다고 모든 데이터 구조가 배열은 아니다. 연결 리스트도 있고 트리 구조도 있고). 어떤 데이터 타입이라도 그 데이터 타입을 손쉽게 다룰 수 있도록 하는 것이 바로 Container다.
손쉽게라는 것이 어떤 의미냐면, 배열의 크기를 사용자가 신경쓰지 않아도, 알아서 조절 해주는 기능이 대표적이다. 해당 데이터 구조에서 최대값, 최소값을 찾아주는 기능도 마련되어있고, 오름차순, 내림차순 정렬도 해줄 수 있다. 강력한 기능을 갖춘 템플릿이다.

즉 Container는 STL의 일부이다.
Container의 종류로는 대표적으로 vector, list, stack, map, set... 등이 있다.


그럼 한 가지 의문이 생기는데, 데이터 타입을 담을 수 있는 컨테이너라면 한 가지 컨테이너만 있으면 되지 않냐는 것이다. 근데 왜 이렇게 종류가 많을까?

그것은 상황에 따라 효율적인 자료구조가 다르다는 것이다.
예를 들어서 임의의 데이터에 접근을 하려고 할 때, 배열은 한 번에 해당 인덱스를 참조 하면 되기 때문에 cost가 1이다. 그러나 linked list에서 특정 데이터에 접근을 하려고 할때는 cost가 n이다(n 번째 데이터에 접근할 때). 이럴 때는 배열이 훨씬 효율적이다.

또 다른 상황은, 어떤 값을 중간에 삽입한다고 해보자. 배열 같은 경우 크기가 N인  배열의 K 번째에 값을 삽입한다고 하면, N-K개의 데이터를 일일이 한 칸씩 밀어줘야 될 것이다. 그러나 linked list는 한 번만에 이것을 해결할 수 있다.

이렇듯 상황에 따라 이득이 되는 데이터 구조가 다르기 때문에 여러가지 종류가 있다.



### Iterator



## 종류
c++ 11 까지는 Iterator가 크게 5가지 카테고리로 나뉜다.
- Input
- Output
- Forward
- Bidirectional
- Random Access


